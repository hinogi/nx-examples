diff --git a/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js b/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
index 440de2635f580959c62717b3c94593f1d6154ad7..6493598231d6d20d085e6e8e5425a23b34365a51 100644
--- a/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
+++ b/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
@@ -5,6 +5,7 @@ const output_1 = require("../../utils/output");
 const utils_1 = require("../utils");
 class InvokeRunnerTerminalOutputLifeCycle {
     constructor(tasks) {
+      console.log('NX tasks', tasks)
         this.tasks = tasks;
         this.failedTasks = [];
         this.cachedTasks = [];
@@ -21,6 +22,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         output_1.output.addVerticalSeparatorWithoutNewLines('cyan');
     }
     endCommand() {
+      console.log('NX endCommand')
         output_1.output.addNewline();
         const taskIds = this.tasks.map((task) => {
             const cached = this.cachedTasks.indexOf(task) !== -1;
@@ -45,6 +47,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         }
     }
     endTasks(taskResults) {
+      console.log('NX taskResults', taskResults);
         for (let t of taskResults) {
             this.taskResults[t.task.id] = t;
             if (t.status === 'failure') {
@@ -62,6 +65,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         }
     }
     printTaskTerminalOutput(task, cacheStatus, terminalOutput) {
+      console.log('NX printTaskTerminalOutput', task, cacheStatus)
         const args = (0, utils_1.getPrintableCommandArgsForTask)(task);
         output_1.output.logCommandOutput(args.join(' '), cacheStatus, terminalOutput);
     }
diff --git a/src/tasks-runner/task-orchestrator.js b/src/tasks-runner/task-orchestrator.js
index 473c0c99501515b9ca1609a4becf0ff23dfd360a..b9160de328796a50ee8a6f96bc6aac0201acb257 100644
--- a/src/tasks-runner/task-orchestrator.js
+++ b/src/tasks-runner/task-orchestrator.js
@@ -204,6 +204,7 @@ class TaskOrchestrator {
     // endregion Batch
     // region Single Task
     async applyFromCacheOrRunTask(doNotSkipCache, task, groupId) {
+      console.log("[DEBUG]: applyFromCacheOrRunTask start")
         // Wait for task to be processed
         const taskSpecificEnv = await this.processedTasks.get(task.id);
         await this.preRunSteps([task], { groupId });
@@ -221,6 +222,7 @@ class TaskOrchestrator {
         let results = doNotSkipCache ? await this.applyCachedResults([task]) : [];
         // the task wasn't cached
         if (results.length === 0) {
+            console.log("[DEBUG]: applyFromCacheOrRunTask results.length === 0")
             const shouldPrefix = streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';
             const targetConfiguration = (0, utils_1.getTargetConfigurationForTask)(task, this.projectGraph);
             if (process.env.NX_RUN_COMMANDS_DIRECTLY !== 'false' &&
@@ -294,6 +296,7 @@ class TaskOrchestrator {
                 });
             }
         }
+        console.log("[DEBUG]: applyFromCacheOrRunTask before postRunSteps")
         await this.postRunSteps([task], results, doNotSkipCache, { groupId });
     }
     async runTaskInForkedProcess(task, env, pipeOutput, temporaryOutputPath, streamOutput) {
@@ -362,6 +365,7 @@ class TaskOrchestrator {
             perf_hooks_1.performance.mark('cache-results-end');
             perf_hooks_1.performance.measure('cache-results', 'cache-results-start', 'cache-results-end');
         }
+       console.log('DEBUG: postRunSteps lifeCycle.endTasks')
         await this.options.lifeCycle.endTasks(results.map((result) => {
             const code = result.status === 'success' ||
                 result.status === 'local-cache' ||
