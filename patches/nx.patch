diff --git a/src/tasks-runner/life-cycle.js b/src/tasks-runner/life-cycle.js
index 4168d75380239273cf46ae84ebc12a65f3a3caba..88db9f7912adecbaef1dd5aacb2de544169087ec 100644
--- a/src/tasks-runner/life-cycle.js
+++ b/src/tasks-runner/life-cycle.js
@@ -34,6 +34,7 @@ class CompositeLifeCycle {
         }
     }
     endTask(task, code) {
+       console.log('DEBUG: compostite life cycle endTask', task, code)
         for (let l of this.lifeCycles) {
             if (l.endTask) {
                 l.endTask(task, code);
diff --git a/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js b/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
index 440de2635f580959c62717b3c94593f1d6154ad7..6493598231d6d20d085e6e8e5425a23b34365a51 100644
--- a/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
+++ b/src/tasks-runner/life-cycles/invoke-runner-terminal-output-life-cycle.js
@@ -5,6 +5,7 @@ const output_1 = require("../../utils/output");
 const utils_1 = require("../utils");
 class InvokeRunnerTerminalOutputLifeCycle {
     constructor(tasks) {
+      console.log('NX tasks', tasks)
         this.tasks = tasks;
         this.failedTasks = [];
         this.cachedTasks = [];
@@ -21,6 +22,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         output_1.output.addVerticalSeparatorWithoutNewLines('cyan');
     }
     endCommand() {
+      console.log('NX endCommand')
         output_1.output.addNewline();
         const taskIds = this.tasks.map((task) => {
             const cached = this.cachedTasks.indexOf(task) !== -1;
@@ -45,6 +47,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         }
     }
     endTasks(taskResults) {
+      console.log('NX taskResults', taskResults);
         for (let t of taskResults) {
             this.taskResults[t.task.id] = t;
             if (t.status === 'failure') {
@@ -62,6 +65,7 @@ class InvokeRunnerTerminalOutputLifeCycle {
         }
     }
     printTaskTerminalOutput(task, cacheStatus, terminalOutput) {
+      console.log('NX printTaskTerminalOutput', task, cacheStatus)
         const args = (0, utils_1.getPrintableCommandArgsForTask)(task);
         output_1.output.logCommandOutput(args.join(' '), cacheStatus, terminalOutput);
     }
diff --git a/src/tasks-runner/task-orchestrator.js b/src/tasks-runner/task-orchestrator.js
index 473c0c99501515b9ca1609a4becf0ff23dfd360a..560b3192cea7d28189e49a4b677036952f7ad7bb 100644
--- a/src/tasks-runner/task-orchestrator.js
+++ b/src/tasks-runner/task-orchestrator.js
@@ -179,31 +179,8 @@ class TaskOrchestrator {
             }, groupId);
         }
     }
-    async runBatch(batch, env) {
-        try {
-            const results = await this.forkedProcessTaskRunner.forkProcessForBatch(batch, this.taskGraph, env);
-            const batchResultEntries = Object.entries(results);
-            return batchResultEntries.map(([taskId, result]) => ({
-                ...result,
-                task: {
-                    ...this.taskGraph.tasks[taskId],
-                    startTime: result.startTime,
-                    endTime: result.endTime,
-                },
-                status: (result.success ? 'success' : 'failure'),
-                terminalOutput: result.terminalOutput,
-            }));
-        }
-        catch (e) {
-            return batch.taskGraph.roots.map((rootTaskId) => ({
-                task: this.taskGraph.tasks[rootTaskId],
-                status: 'failure',
-            }));
-        }
-    }
-    // endregion Batch
-    // region Single Task
     async applyFromCacheOrRunTask(doNotSkipCache, task, groupId) {
+      console.log("[DEBUG]: applyFromCacheOrRunTask start")
         // Wait for task to be processed
         const taskSpecificEnv = await this.processedTasks.get(task.id);
         await this.preRunSteps([task], { groupId });
@@ -221,6 +198,7 @@ class TaskOrchestrator {
         let results = doNotSkipCache ? await this.applyCachedResults([task]) : [];
         // the task wasn't cached
         if (results.length === 0) {
+            console.log("[DEBUG]: applyFromCacheOrRunTask results.length === 0")
             const shouldPrefix = streamOutput && process.env.NX_PREFIX_OUTPUT === 'true';
             const targetConfiguration = (0, utils_1.getTargetConfigurationForTask)(task, this.projectGraph);
             if (process.env.NX_RUN_COMMANDS_DIRECTLY !== 'false' &&
@@ -294,8 +272,34 @@ class TaskOrchestrator {
                 });
             }
         }
+        console.log("[DEBUG]: applyFromCacheOrRunTask results", results)
+        console.log("[DEBUG]: applyFromCacheOrRunTask before postRunSteps")
         await this.postRunSteps([task], results, doNotSkipCache, { groupId });
     }
+    async runBatch(batch, env) {
+        try {
+            const results = await this.forkedProcessTaskRunner.forkProcessForBatch(batch, this.taskGraph, env);
+            const batchResultEntries = Object.entries(results);
+            return batchResultEntries.map(([taskId, result]) => ({
+                ...result,
+                task: {
+                    ...this.taskGraph.tasks[taskId],
+                    startTime: result.startTime,
+                    endTime: result.endTime,
+                },
+                status: (result.success ? 'success' : 'failure'),
+                terminalOutput: result.terminalOutput,
+            }));
+        }
+        catch (e) {
+            return batch.taskGraph.roots.map((rootTaskId) => ({
+                task: this.taskGraph.tasks[rootTaskId],
+                status: 'failure',
+            }));
+        }
+    }
+    // endregion Batch
+    // region Single Task
     async runTaskInForkedProcess(task, env, pipeOutput, temporaryOutputPath, streamOutput) {
         try {
             const usePtyFork = process.env.NX_NATIVE_COMMAND_RUNNER !== 'false';
@@ -362,20 +366,24 @@ class TaskOrchestrator {
             perf_hooks_1.performance.mark('cache-results-end');
             perf_hooks_1.performance.measure('cache-results', 'cache-results-start', 'cache-results-end');
         }
-        await this.options.lifeCycle.endTasks(results.map((result) => {
-            const code = result.status === 'success' ||
-                result.status === 'local-cache' ||
-                result.status === 'local-cache-kept-existing' ||
-                result.status === 'remote-cache'
-                ? 0
-                : 1;
-            return {
-                ...result,
-                task: result.task,
-                status: result.status,
-                code,
-            };
-        }), { groupId });
+       console.log('DEBUG: postRunSteps lifeCycle.endTasks', results)
+      console.log('DEBUG: postRunSteps lifeCycle = this.options.lifeCycle', this.options.lifeCycle)
+      const newResults = results.map((result) => {
+        const code = result.status === 'success' ||
+            result.status === 'local-cache' ||
+            result.status === 'local-cache-kept-existing' ||
+            result.status === 'remote-cache'
+            ? 0
+            : 1;
+        return {
+            ...result,
+            task: result.task,
+            status: result.status,
+            code,
+        };
+    })
+    console.log('DEBUG: postRunSteps newResults', newResults)
+        await this.options.lifeCycle.endTasks(newResults, { groupId });
         this.complete(results.map(({ task, status }) => {
             return {
                 taskId: task.id,
